# 関数呼び出し

## プロローグ、エピローグ

関数実行前に行う処理をプロローグ、関数実行後に行う処理をエピローグという。

主にレジスタの退避と復元を行う。

## レジスタ

関数呼び出しに関して、RKISAでは、レジスタを３種類に分けている。

1. T (Temporary) レジスタ

関数側が自由に書き換えることができる。

関数の前後で保存したい場合、Caller（関数を呼び出した側）の責任で保存する必要がある。

2. S (Save) レジスタ

関数呼び出しの前後で値が保存されるレジスタ。

Callee（呼び出された側、関数側）が値を保存する。

関数内で使いたければ、関数が処理を行う前に、退避しておく必要がある。

3. A (Argument) レジスタ

関数の引数と返値を入れるレジスタ。

関数側が自由に書き換えることができるので、Tレジスタの一種ともみなせるが、呼び出し側は変更を前提として扱ったほうがよい。

```C:
{
    int a;       // a:A
    int b;       //  |  b:S
    int c;       //  |   |  c:S
    c = hoge(a); //  x   |   |
    int d;       //      |   |  d:T
    d = c+b;     //      |   |   |
}
```

## スタックポインタ、フレームポインタ

現在実行中の関数に割り当てられたスタックの底を指すのが、フレームポインタ。

関数開始時に、呼び出し側のフレームポインタを退避し、自身のフレームポインタをセットする。

## リターンアドレス

関数呼び出し（call func = jump ra zero func）により、戻りアドレスが RA レジスタに入れられる。

関数の後に帰ってくる


## 関数呼び出しの流れ

### 呼び出し側

1. Push T0-3, A0-3 (optional)
2. Push RA
3. Push Args
4. Call (ra <= pc+1)

### 関数プロローグ

1. Push FP
1. FP <= SP
2. Push FP
3. Push SP
4. Push S0-3 (optional)

### 関数エピローグ

FPを手がかりに、レジスタの復元を行う。

1. SP <= FP
2. Pop S0-3
3. Ret (pc <= ra)

### 呼び出し側




- ローカル変数
- S レジスタ
- FP

- RA

- 関数引数

## 最適化への指針

このように、関数呼び出しには、かなりのオーバーヘッドがある。

### インライン化

### 退避レジスタの削減
