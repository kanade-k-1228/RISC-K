; -----------------------------------------------
; システム

zero:
_reset:
    jump zero zero _main

_intr:
    ; レジスタ退避
    store sp sp 0
    store fp sp 15
    subi  sp sp 14
    store s0 sp 13
    store s1 sp 12
    store s2 sp 11
    store s3 sp 10
    store t0 sp 9
    store t1 sp 8
    store t2 sp 7
    store t3 sp 6
    store a0 sp 5
    store a1 sp 4
    store a2 sp 3
    store a3 sp 2
    store ra sp 1
    add   fp sp zero
    ; 割り込み先にジャンプ
    andi  t0 csr 0x004
    brlt  zero t0 intr0
    andi  t0 csr 0x008
    brlt  zero t0 intr1
    andi  t0 csr 0x010
    brlt  zero t0 intr2
    andi  t0 csr 0x020
    brlt  zero t0 intr3
_iret:
    ; レジスタの復元
    add   sp fp zero
    load  a3 sp 4
    load  a2 sp 3
    load  a1 sp 2
    load  a0 sp 1
    addi  sp sp 4
    load  sp sp 0
    ; 割り込みから復帰
    jump zero ira zero

; プログラム開始前処理
_main:
    loadi sp 0xffff
    loadi fp 0xffff
    jump  zero zero os_init

; プログラム終了後処理
_ret:
    ori csr csr 0x100 ; クロック停止

; ---------------------------------------------------
; ハードウェア固有の処理

; シリアル送信
; loadi a0 0x41
; jump ra zero _print
; > A
_print:
    add cout a0 zero
    ori csr csr 0x80 ; set send flag
    jump zero ra zero

; ['A','B','C','\0']
_print_str:

; 16進数として値を出力
; loadi a0 0x01EF
; jump ra zero _print_hex
; > 01EF
_print_hex:
    loadi a3 4
    loadi a2 10
_print_hex_for:
    breq a3 zero _print_hex_break
    lrot a0 a0 zero
    lrot a0 a0 zero
    lrot a0 a0 zero
    lrot a0 a0 zero
    andi a1 a0 0x00F ; a1 = a0 & f
; cout = a1 < 10 ? a1 + '0' : a1 + ('A' - 10)
    brlt a1 a2 _print_hex_number
_print_hex_alphabet:
    addi cout a1 0x37
    jump zero zero _print_hex_continue
_print_hex_number:
    addi cout a1 0x30
_print_hex_continue:
    ori  csr csr 0x80 ; set send flag
    subi a3 a3 1
    jump zero zero _print_hex_for
_print_hex_break:
    jump zero ra 0

; ---------------------------------------------------
; OS

; OSの初期化
os_init:
    jump zero zero init

os_task_setup:
    store a1 a0 0 ; Stack Top
    store a1 a0 1 ; Stack Base
    jump zero ra zero ; return

os_save_context:
    subi sp sp 16
    store t0 sp 0
    store t1 sp 1
    store t2 sp 2
    store t3 sp 3
    store t1 sp 1
    store t1 sp 1
    store t1 sp 1
    store t1 sp 1
os_next_task:
    ; タスクの優先度と状態から、次に実行するタスクを決定する
os_restore_context:
    ; タスクを再開
    jump zero ra zero

; ヒープに関する

os_start_scheduler:
    ; 優先度順に

os_task_wait:
    ; コンテキスト保存
    ; 次のタスクを決定
    ; running = &next_task_tbc
    ; コンテキスト復元
    ; ジャンプ
    jump zero ra zero

os_task_resume:

; -----------------------------------------------
; ユーザプログラム

; 各割り込みの処理
intr1:
    jump zero zero _iret
intr2:
    jump zero zero _iret
intr3:
    jump zero zero _iret
intr4:
    jump zero zero _iret

init:
    ; setup task A
    loadi a0 0x1000 ; &TBC_A
    loadi a1 0xffff ; stack_base
    loadi a2 task_a ; entry address
    jump ra zero os_task_setup
    ; setup task B
    loadi a0 0x2000 ; &TBC_B
    loadi a1 0xefff ; stack_base
    loadi a2 task_b ; entry address
    ; setup task C
    loadi a0 0x3000 ; &TBC_C
    loadi a1 0xdfff ; stack_base
    loadi a2 task_c ; entry address
    ; os start
    jump zero zero os_start_scheduler

task_a:
    loadi cout 0x54
    loadi send 1
    loadi cout 0x61
    loadi send 1
    loadi cout 0x73
    loadi send 1
    loadi cout 0x6B
    loadi send 1
    loadi cout 0x41
    loadi send 1
    loadi cout 0x0A
    loadi send 1
    loadi t0 0
    loadi t1 10
loop:
    brlt  t1 t0 break

    jump  zero zero loop
break:
    jump zero zero os_task_wait

task_b:

task_c:
