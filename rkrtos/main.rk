; -----------------------------------------------
; システム

zero:
_reset:
    jump zero zero _main

_intr:
    ; コンテキストの保存
    subi  sp sp 14 ; スタックを確保
    store s0 sp 14
    store s1 sp 13
    store s2 sp 12
    store s3 sp 11
    store t0 sp 10
    store t1 sp 9
    store t2 sp 8
    store t3 sp 7
    store a0 sp 6
    store a1 sp 5
    store a2 sp 4
    store a3 sp 3
    store fp sp 2
    store ra sp 1
    ; スタックポインタの保存
    load t0 zero 0x0040 ; t0 = running
    store sp t0 0       ; t0.sp = sp
    ; 割り込み先にジャンプ
    andi  t0 csr 0x004
    brlt  zero t0 intr0
    andi  t0 csr 0x008
    brlt  zero t0 intr1
    andi  t0 csr 0x010
    brlt  zero t0 intr2
    andi  t0 csr 0x020
    brlt  zero t0 intr3
_iret:
    ; レジスタの復元
    add   sp fp zero
    load  a3 sp 4
    load  a2 sp 3
    load  a1 sp 2
    load  a0 sp 1
    addi  sp sp 4
    load  sp sp 0
    ; 割り込みから復帰
    jump zero ira zero

; プログラム開始前処理
_main:
    loadi sp 0xffff
    loadi fp 0xffff
    jump  zero zero os_init

; プログラム終了後処理
_exit:
    ori csr csr 0x100 ; クロック停止

; ---------------------------------------------------
; 標準ライブラリ

; シリアル送信
; loadi a0 0x41
; jump ra zero _print
; > A
_print:
    add cout a0 zero
    ori csr csr 0x80 ; set send flag
    jump zero ra zero

; ['A','B','C','\0']
_print_str:

; 16進数として値を出力
; loadi a0 0x01EF
; jump ra zero _print_hex
; > 01EF
_print_hex:
    loadi a3 4
    loadi a2 10
_print_hex_for:
    breq a3 zero _print_hex_break
    lrot a0 a0 zero
    lrot a0 a0 zero
    lrot a0 a0 zero
    lrot a0 a0 zero
    andi a1 a0 0x00F ; a1 = a0 & f
; cout = a1 < 10 ? a1 + '0' : a1 + ('A' - 10)
    brlt a1 a2 _print_hex_number
_print_hex_alphabet:
    addi cout a1 0x37
    jump zero zero _print_hex_continue
_print_hex_number:
    addi cout a1 0x30
_print_hex_continue:
    ori  csr csr 0x80 ; set send flag
    subi a3 a3 1
    jump zero zero _print_hex_for
_print_hex_break:
    jump zero ra 0

; ---------------------------------------------------
; OS

; OSの初期化
os_init:
    loadi t0 0x42 
    store t0 zero 0x41
    jump  ra zero init
    ori   csr csr 0x0001 ; 割り込み許可
    jump  zero zero os_task_next

; タスクの初期化
; a0 tcb
; a1 stack_base
; a2 entry address
; a3 state
os_task_setup:
    ; task_end += 3
    load  t0 zero 0x0041 ; t0 = task_end
    addi  t0 t0 3
    store t0 zero 0x0041
    ; set tcb
    store a1 a0 1 ; stack_base => tcb.bp
    subi  a1 a1 14 ; sp -= 14
    store a1 a0 0 ; stack_pointer => tcb.sp
    store a3 a0 2 ; state => tcb.state
    ; init stack
    store zero a1 14
    store zero a1 13
    store zero a1 12
    store zero a1 11
    store zero a1 10
    store zero a1 9
    store zero a1 8
    store zero a1 7
    store zero a1 6
    store zero a1 5
    store zero a1 4
    store zero a1 3
    store zero a1 2
    store a2 a1 1 ; ra = entry_address
    jump zero ra zero ; return

; タスクの終了
os_task_exit:
    ; 状態を exit に変更
    load  t0 zero 0x0040 ; t0 = running
    loadi t1 2
    store t1 t0 2       ; t0.state = 2(exit)
    jump  zero zero os_task_next

; 実行中のタスクを一時停止
os_task_wait:
    ; コンテキストの保存
    subi  sp sp 14 ; スタックを確保
    store s0 sp 14
    store s1 sp 13
    store s2 sp 12
    store s3 sp 11
    store t0 sp 10
    store t1 sp 9
    store t2 sp 8
    store t3 sp 7
    store a0 sp 6
    store a1 sp 5
    store a2 sp 4
    store a3 sp 3
    store fp sp 2
    store ra sp 1
    ; スタックポインタの保存
    load t0 zero 0x0040 ; t0 = running
    store sp t0 0       ; t0.sp = sp
    ; 状態を waiting に変更
    loadi t1 1
    store t1 t0 2       ; t0.state = 1(waiting)
    jump zero zero os_task_next

; 指定した ID のタスクを Ready 状態にする
; a0 : task id
os_task_ready:
    ; コンテキストの保存
    subi  sp sp 14 ; スタックを確保
    store s0 sp 14
    store s1 sp 13
    store s2 sp 12
    store s3 sp 11
    store t0 sp 10
    store t1 sp 9
    store t2 sp 8
    store t3 sp 7
    store a0 sp 6
    store a1 sp 5
    store a2 sp 4
    store a3 sp 3
    store fp sp 2
    store ra sp 1
    ; スタックポインタの保存
    load t0 zero 0x0040 ; t0 = running
    store sp t0 0       ; t0.sp = sp
    ; 状態を ready に変更
    ; a0 = a0 * 4 + 0x42
    store zero a0 2     ; a0.state = ready
    jump zero zero os_task_next

os_save_context:
    subi  sp sp 14 ; スタックを確保
    store s0 sp 14
    store s1 sp 13
    store s2 sp 12
    store s3 sp 11
    store t0 sp 10
    store t1 sp 9
    store t2 sp 8
    store t3 sp 7
    store a0 sp 6
    store a1 sp 5
    store a2 sp 4
    store a3 sp 3
    store fp sp 2
    store ra sp 1
    load t0 zero 0x0040 ; t0 = running
    store sp t0 0       ; t0.sp = sp

os_task_next:
    ; 上から順に、tcb.state が running か調べる
    ; ReadyのTCB => running する
    loadi t0 0x0042 ; t0 = taskA
    load  t1 zero 0x0041 ; t1 = task_end
os_task_next_loop:
    breq  t0 t1 os_task_next_break
    load  t2 t0 2   ; t2 = t0.state
    breq  t2 zero os_task_next_update_running ; if ready
    addi  t0 t0 3   ; t0 += 3
    jump zero zero os_task_next_loop
os_task_next_break:
    ; 全てのタスクが exit なら、exitする
    jump zero zero _exit
os_task_next_update_running:
    store t0 zero 0x0040

os_restore_context:
    ; タスクを再開
    load t0 zero 0x0040 ; t0 = running
    load sp t0 0        ; sp = t0.sp
    load ra sp 1
    load fp sp 2
    load a3 sp 3
    load a2 sp 4
    load a1 sp 5
    load a0 sp 6
    load t3 sp 7
    load t2 sp 8
    load t1 sp 9
    load t0 sp 10
    load s3 sp 11
    load s2 sp 12
    load s1 sp 13
    load s0 sp 14
    addi sp sp 14 ; スタックを解放
    jump zero ra zero

; ヒープ
os_heap_aloc:
os_heap_free:

; -----------------------------------------------
; ユーザプログラム

; 各割り込みの処理
intr0:
    jump zero zero _iret
intr1:
    jump zero zero _iret
intr2:
    jump zero zero _iret
intr3:
    jump zero zero _iret

init:
    add  s0 ra zero ; s0 <= ra
    ; setup task A
    loadi a0 0x0042 ; &TBC_A
    loadi a1 0xefff ; stack_base
    loadi a2 task_a ; entry address
    loadi a3 0      ; ready
    jump ra zero os_task_setup
    ; setup task B
    loadi a0 0x0045 ; &TBC_B
    loadi a1 0xdfff ; stack_base
    loadi a2 task_b ; entry address
    loadi a3 0      ; ready
    jump ra zero os_task_setup
    ; setup task C
    loadi a0 0x0048 ; &TBC_C
    loadi a1 0xcfff ; stack_base
    loadi a2 task_c ; entry address
    loadi a3 0      ; ready
    jump ra zero os_task_setup
    ; os start
    add  ra s0 zero ; ra <= s0 
    jump zero ra 0

task_a:
    loadi cout 0x53
    ori   csr csr 0x80
    loadi cout 0x74
    ori   csr csr 0x80
    loadi cout 0x61
    ori   csr csr 0x80
    loadi cout 0x72
    ori   csr csr 0x80
    loadi cout 0x74
    ori   csr csr 0x80
    loadi cout 0x20
    ori   csr csr 0x80
    loadi cout 0x41
    ori   csr csr 0x80
    loadi cout 0x0A
    ori   csr csr 0x80
    loadi s0 0xAAA0
    loadi s1 0xAAA1
    loadi s2 0xAAA2
    loadi s3 0xAAA3
    loadi t0 0xAAB0
    loadi t1 0xAAB1
    loadi t2 0xAAB2
    loadi t3 0xAAB3
    loadi a0 0xAAC0
    loadi a1 0xAAC1
    loadi a2 0xAAC2
    loadi a3 0xAAC3
    jump  ra zero os_task_wait
    loadi cout 0x52
    ori   csr csr 0x80
    loadi cout 0x65
    ori   csr csr 0x80
    loadi cout 0x73
    ori   csr csr 0x80
    loadi cout 0x75
    ori   csr csr 0x80
    loadi cout 0x6d
    ori   csr csr 0x80
    loadi cout 0x65
    ori   csr csr 0x80
    loadi cout 0x20
    ori   csr csr 0x80
    loadi cout 0x41
    ori   csr csr 0x80
    loadi cout 0x0A
    ori   csr csr 0x80
    ; ready B
    loadi a0 0x0045
    jump  ra zero os_task_ready
    jump  ra zero os_task_exit
    
task_b:
    loadi cout 0x53
    ori   csr csr 0x80
    loadi cout 0x74
    ori   csr csr 0x80
    loadi cout 0x61
    ori   csr csr 0x80
    loadi cout 0x72
    ori   csr csr 0x80
    loadi cout 0x74
    ori   csr csr 0x80
    loadi cout 0x20
    ori   csr csr 0x80
    loadi cout 0x42
    ori   csr csr 0x80
    loadi cout 0x0A
    ori   csr csr 0x80
    loadi s0 0xBBA0
    loadi s1 0xBBA1
    loadi s2 0xBBA2
    loadi s3 0xBBA3
    loadi t0 0xBBB0
    loadi t1 0xBBB1
    loadi t2 0xBBB2
    loadi t3 0xBBB3
    loadi a0 0xBBC0
    loadi a1 0xBBC1
    loadi a2 0xBBC2
    loadi a3 0xBBC3
    jump  ra zero os_task_wait
    loadi cout 0x52
    ori   csr csr 0x80
    loadi cout 0x65
    ori   csr csr 0x80
    loadi cout 0x73
    ori   csr csr 0x80
    loadi cout 0x75
    ori   csr csr 0x80
    loadi cout 0x6d
    ori   csr csr 0x80
    loadi cout 0x65
    ori   csr csr 0x80
    loadi cout 0x20
    ori   csr csr 0x80
    loadi cout 0x42
    ori   csr csr 0x80
    loadi cout 0x0A
    ori   csr csr 0x80
    jump  ra zero os_task_exit

task_c:
    loadi cout 0x53
    ori   csr csr 0x80
    loadi cout 0x74
    ori   csr csr 0x80
    loadi cout 0x61
    ori   csr csr 0x80
    loadi cout 0x72
    ori   csr csr 0x80
    loadi cout 0x74
    ori   csr csr 0x80
    loadi cout 0x20
    ori   csr csr 0x80
    loadi cout 0x43
    ori   csr csr 0x80
    loadi cout 0x0A
    ori   csr csr 0x80
    loadi s0 0xCCA0
    loadi s1 0xCCA1
    loadi s2 0xCCA2
    loadi s3 0xCCA3
    loadi t0 0xCCB0
    loadi t1 0xCCB1
    loadi t2 0xCCB2
    loadi t3 0xCCB3
    loadi a0 0xCCC0
    loadi a1 0xCCC1
    loadi a2 0xCCC2
    loadi a3 0xCCC3
    ; ready A
    loadi a0 0x0042
    jump  ra zero os_task_ready
    loadi cout 0x52
    ori   csr csr 0x80
    loadi cout 0x65
    ori   csr csr 0x80
    loadi cout 0x73
    ori   csr csr 0x80
    loadi cout 0x75
    ori   csr csr 0x80
    loadi cout 0x6d
    ori   csr csr 0x80
    loadi cout 0x65
    ori   csr csr 0x80
    loadi cout 0x20
    ori   csr csr 0x80
    loadi cout 0x43
    ori   csr csr 0x80
    loadi cout 0x0A
    ori   csr csr 0x80
    jump  ra zero os_task_exit
