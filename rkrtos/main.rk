zero:
_reset:
    jump zero zero _main

_intr:
    ; レジスタ退避
    store sp sp 0
    store fp 
    subi  sp sp 14
    store s0 sp 13
    store s1 sp 12
    store s2 sp 11
    store s3 sp 10
    store t0 sp 9
    store t1 sp 8
    store t2 sp 7
    store t3 sp 6
    store a0 sp 5
    store a1 sp 4
    store a2 sp 3
    store a3 sp 2
    store ra sp 1
    
    add   fp sp zero
    ; 割り込み先にジャンプ
    loadi t0  0x0001
    breq  iid t0 intr1
    loadi t0  0x0002
    breq  iid t0 intr2
    loadi t0  0x0003
    breq  iid t0 intr3
    loadi t0  0x0004
    breq  iid t0 intr4
_iret:
    ; レジスタの復元
    add   sp fp zero
    load  a3 sp 4
    load  a2 sp 3
    load  a1 sp 2
    load  a0 sp 1
    addi  sp sp 4
    load  sp sp 0
    ; 割り込みから復帰
    jump zero ira zero

; プログラム開始前処理
_main:
    loadi sp 0xffff
    loadi fp 0xffff
    ori   scr scr 0b0000'1000'0000'0000 ; 割り込み許可
    jump  zero zero os_init

; プログラム終了後処理
_ret:
    jump zero zero _ret
    ; ori scr scr 0b1000'0000'0000'0000 ; クロック停止

; ---------------------------------------------------
; ハードウェア固有の処理

; シリアル送信
; loadi a0 'a'
; jump ra zero _print
_print:
    store a0 zero 0x0030
    loadi a1 0x0001
    store a1 zero 0x0031
    jump zero ra zero

; ---------------------------------------------------
; OS

; OSの初期化
os_init:
    jump zero zero init

os_task_setup:
    store a1 a0 0 ; Stack Top
    store a1 a0 1 ; Stack Base
    jump zero ra zero ; return

os_save_context:
    subi sp sp 16
    store t0 sp 0
    store t1 sp 1
    store t2 sp 2
    store t3 sp 3
    store t1 sp 1
    store t1 sp 1
    store t1 sp 1
    store t1 sp 1

os_restore_context:

os_malloc:

os_free:

os_start_scheduler:
    ; 優先度順に

os_task_wait:
    ; コンテキスト保存
    ; 次のタスクを決定
    ; running = &next_task_tbc
    ; コンテキスト復元
    ; ジャンプ
    jump zero ra zero

os_task_resume:

; 各割り込みの処理
intr1:
    jump zero zero _iret
intr2:
    jump zero zero _iret
intr3:
    jump zero zero _iret
intr4:
    jump zero zero _iret

init:
    ; setup task A
    loadi a0 0x1000 ; &TBC_A
    loadi a1 0xffff ; stack_base
    loadi a2 task_a ; entry address
    jump ra zero os_task_setup
    ; setup task B
    loadi a0 0x2000 ; &TBC_B
    loadi a1 0xefff ; stack_base
    loadi a2 task_b ; entry address
    ; setup task C
    loadi a0 0x3000 ; &TBC_C
    loadi a1 0xdfff ; stack_base
    loadi a2 task_c ; entry address
    jump zero zero os_start_scheduler

task_a:
    loadi cout 0x54
    loadi send 1
    loadi cout 0x61
    loadi send 1
    loadi cout 0x73
    loadi send 1
    loadi cout 0x6B
    loadi send 1
    loadi cout 0x41
    loadi send 1
    loadi cout 0x0A
    loadi send 1
    loadi t0 0
    loadi t1 10
loop:
    brlt  t1 t0 break

    jump  zero zero loop
break:
    jump zero zero os_task_wait

task_b:

task_c:
