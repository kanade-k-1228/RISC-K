; -----------------------------------------------
; システム

zero:
_reset:
    jump zero zero _main

; CSR Bits

#0x0100 clock_stop

#0xfffe intr_disable
#0x0001 intr_enable

#0x0004 intr0_flag
#0x0008 intr1_flag
#0x0010 intr2_flag
#0x0020 intr3_flag

#0xfffb intr0_flag_clear
#0xfff7 intr1_flag_clear
#0xffef intr2_flag_clear
#0xffdf intr3_flag_clear

_intr:
    andi  csr csr intr_disable ; 二重割り込み禁止
    ; コンテキストの保存
    subi  sp sp 14 ; スタックを確保
    store s0 sp 14
    store s1 sp 13
    store s2 sp 12
    store s3 sp 11
    store t0 sp 10
    store t1 sp 9
    store t2 sp 8
    store t3 sp 7
    store a0 sp 6
    store a1 sp 5
    store a2 sp 4
    store a3 sp 3
    store fp sp 2
    store ra sp 1
    load  t0 zero task_running
    store ira t0 .ra ; 戻りアドレスの保存
    store sp t0 .sp  ; スタックポインタの保存
    ; 割り込みフラグが立っている場合
    ; 割り込み番号の処理にジャンプ
    andi  t0 csr intr0_flag
    brlt  zero t0 intr0
    andi  t0 csr intr1_flag
    brlt  zero t0 intr1
    andi  t0 csr intr2_flag
    brlt  zero t0 intr2
    andi  t0 csr intr3_flag
    brlt  zero t0 intr3
_iret:
    ; 割り込みが全て処理された
    jump zero zero os_restore_context

; プログラム開始前処理
_main:
    loadi sp 0xffff
    loadi fp 0xffff
    jump  zero zero os_init

; プログラム終了後処理
_exit:
    ori csr csr clock_stop

; ---------------------------------------------------
; 標準ライブラリ

; シリアル送信
; a0 > string_address
; ['A','B','C','\0']
_print_str:

; 16進数出力
; a0 > uint16
print_hex:
    loadi a3 4
    loadi a2 10
print_hex_for:
    breq a3 zero print_hex_break
    lrot a0 a0 zero
    lrot a0 a0 zero
    lrot a0 a0 zero
    lrot a0 a0 zero
    andi a1 a0 0x00F ; a1 = a0 & f
; cout = a1 < 10 ? a1 + '0' : a1 + ('A' - 10)
    brlt a1 a2 print_hex_number
print_hex_alphabet:
    addi cout a1 0x37 ; A - 10
    jump zero zero print_hex_continue
print_hex_number:
    addi cout a1 '0'
print_hex_continue:
    subi a3 a3 1
    jump zero zero print_hex_for
print_hex_break:
    jump zero ra 0

#0x0A '\n'
#0x20 ''
#0x21 '!'
#0x22 '"'
#0x23 '#'
#0x3A ':'
#0x3B ';'
#0x3C '<'
#0x3D '='
#0x3E '>'

#0x30 '0'
#0x31 '1'
#0x32 '2'
#0x33 '3'
#0x34 '4'
#0x35 '5'
#0x36 '6'
#0x37 '7'
#0x38 '8'
#0x39 '9'

#0x41 'A'
#0x42 'B'
#0x43 'C'
#0x44 'D'
#0x45 'E'
#0x46 'F'
#0x47 'G'
#0x48 'H'
#0x49 'I'
#0x4A 'J'
#0x4B 'K'
#0x4C 'L'
#0x4D 'M'
#0x4E 'N'
#0x4F 'O'
#0x50 'P'
#0x51 'Q'
#0x52 'R'
#0x53 'S'
#0x54 'T'
#0x55 'U'
#0x56 'V'
#0x57 'W'
#0x58 'X'
#0x59 'Y'
#0x5A 'Z'

#0x61 'a'
#0x62 'b'
#0x63 'c'
#0x64 'd'
#0x65 'e'
#0x66 'f'
#0x67 'g'
#0x68 'h'
#0x69 'i'
#0x6A 'j'
#0x6B 'k'
#0x6C 'l'
#0x6D 'm'
#0x6E 'n'
#0x6F 'o'
#0x70 'p'
#0x71 'q'
#0x72 'r'
#0x73 's'
#0x74 't'
#0x75 'u'
#0x76 'v'
#0x77 'w'
#0x78 'x'
#0x79 'y'
#0x7A 'z'

; ---------------------------------------------------
; OS - グローバル変数

#4 os_global_size
@0x0040 heap_top     ; ヒープメモリの先頭
@0x0041 heap_bottom  ; ヒープメモリの末尾
@0x0042 task_running ; 実行中のタスク(TCB)のアドレス
@0x0043 task_list    ; タスク(TCB)連結リストの先頭のアドレス
#0x0040 ram_top
#0xdfff ram_bottom

; ---------------------------------------------------
; OS - 初期化

os_init:
    ; グローバル変数の初期化
    loadi t0 ram_top
    addi  t0 t0 os_global_size
    addi  t0 t0 user_global_size
    store t0 zero heap_top
    loadi t0 ram_bottom
    store t0 zero heap_bottom
    store zero zero task_running
    store zero zero task_list
    ; 各種オブジェクトの初期化
    jump  ra zero init_tasks
    ; jump  ra zero os_heap_init
    jump  zero zero os_task_switch

; ---------------------------------------------------
; OS - タスク管理機能

; struct tcb
@0x0000 .next
@0x0001 .sp
@0x0002 .bp
@0x0003 .ra
@0x0004 .state
#5 tcb_size
; enum task_state
#0 task_state_ready
#1 task_state_waiting
#2 task_state_exit

; タスクの初期化
; a0 > initial_state
; a1 > stack_size
; a2 > entry_address
; a0 < task_pointer
os_task_setup:
    loadi t1 task_list
os_task_setup_next:
    add   t0 t1 zero  ; t0 <= t1 
    load  t1 t0 .next ; t0 の次のアイテムのアドレスを、t1に格納する
    brlt  zero t1 os_task_setup_next
    ; t0 が、リストの末尾のアドレスを指している
    ; [task_list] -> A[next=B] -> B[next=null] -> x
    ; 新たに追加するTCBのアドレスを、リストの末尾に連結する
    load  t1 zero heap_top
    store t1 t0 .next
    ; t0 は新たに追加されたTCBのアドレスを指す
    add   t0 t1 zero
    ; メモリを確保する
    addi  t1 t1 tcb_size
    store t1 zero heap_top
    ; タスクの初期化
    store a0 t0 .state
    store a2 t0 .ra
    ; スタックの確保
    load  t1 zero heap_bottom
    store t1 t0 .bp ; ベースポインタを登録
    sub   t2 t1 a1  ; スタックサイズ (a1) メモリを確保
    store t2 zero heap_bottom
    add   t2 t1 zero ; t2 = fp
    subi  t1 t1 14  ; 初期コンテキスト分だけスタックポインタを進める
    store t1 t0 .sp
    ; 初期コンテキストをスタックに追加
    store zero t1 14 ; s0
    store zero t1 13 ; s1
    store zero t1 12 ; s2
    store zero t1 11 ; s3
    store zero t1 10 ; t0
    store zero t1 9  ; t1
    store zero t1 8  ; t2
    store zero t1 7  ; t3
    store zero t1 6  ; a0
    store zero t1 5  ; a1
    store zero t1 4  ; a2
    store zero t1 3  ; a3
    store t2 t1 2  ; fp
    loadi t2 os_task_exit
    store t2 t1 1  ; ra = exit
    add  a0 t0 zero   ; return task_pointer
    jump zero ra zero ; return

; タスクの終了
os_task_exit:
    andi  csr csr 0xfffe ; 割り込み禁止
    ; 状態を exit に変更
    load  t0 zero task_running
    loadi t1 task_state_exit
    store t1 t0 .state
    jump  zero zero os_task_switch

; 実行中のタスクを一時停止
os_task_wait:
    andi  csr csr 0xfffe ; 割り込み禁止
    ; コンテキストの保存
    subi  sp sp 14 ; スタックを確保
    store s0 sp 14
    store s1 sp 13
    store s2 sp 12
    store s3 sp 11
    store t0 sp 10
    store t1 sp 9
    store t2 sp 8
    store t3 sp 7
    store a0 sp 6
    store a1 sp 5
    store a2 sp 4
    store a3 sp 3
    store fp sp 2
    store ra sp 1
    ; TCB の更新
    load t0 zero task_running
    store sp t0 .sp
    store ra t0 .ra
    ; 状態を waiting に変更
    loadi t1 task_state_waiting
    store t1 t0 .state
    jump zero zero os_task_switch

; 指定した ID のタスクを Ready 状態にする
; a0 > task id
os_task_ready:
    andi  csr csr 0xfffe ; 割り込み禁止
    ; コンテキストの保存
    subi  sp sp 14 ; スタックを確保
    store s0 sp 14
    store s1 sp 13
    store s2 sp 12
    store s3 sp 11
    store t0 sp 10
    store t1 sp 9
    store t2 sp 8
    store t3 sp 7
    store a0 sp 6
    store a1 sp 5
    store a2 sp 4
    store a3 sp 3
    store fp sp 2
    store ra sp 1
    ; TCB の更新
    load t0 zero task_running
    store sp t0 .sp
    store ra t0 .ra
    ; 状態を ready に変更
    loadi t1 task_state_ready
    store t1 a0 .state
    jump zero zero os_task_switch

os_task_switch:
    ; タスクリストから、Ready のタスクを探す
    loadi t1 task_list
    loadi t3 task_state_ready
os_task_switch_next:
    add   t0 t1 zero  ; t0 <= t1 
    load  t2 t0 .state
    breq  t2 t3 os_task_switch_found_ready
    load  t1 t0 .next ; t0 の次のアイテムのアドレスを、t1に格納する
    brlt  zero t1 os_task_switch_next
    ; 末尾に到達 =  Ready が見つからなかった
    ; 全てのタスクが exit なら、exitする
    jump zero zero _exit
os_task_switch_found_ready:
    store t0 zero task_running

os_restore_context:
    ; タスクを再開
    load t0 zero task_running
    load sp t0 .sp  ; スタックポインタを復元
    load ira t0 .ra ; 戻りアドレスを 「IRA」に復元
    load ra sp 1
    load fp sp 2
    load a3 sp 3
    load a2 sp 4
    load a1 sp 5
    load a0 sp 6
    load t3 sp 7
    load t2 sp 8
    load t1 sp 9
    load t0 sp 10
    load s3 sp 11
    load s2 sp 12
    load s1 sp 13
    load s0 sp 14
    addi sp sp 14 ; スタックを解放
    ori  csr csr 0x0001 ; 割り込み許可
    jump zero ira zero ; 中断地点に戻る

; -----------------------------------------------
; メモリ管理機能

os_heap_init:
os_heap_aloc:
os_heap_free:

; -----------------------------------------------
; 排他制御

os_lock_init:
os_lock_aloc:
os_lock_free:
; -----------------------------------------------
; ユーザプログラム

#3 user_global_size

@0x0044 task_id_a
@0x0045 task_id_b
@0x0046 task_id_c


; 各割り込みの処理
intr0:
    loadi cout ''
    loadi cout '<'
    loadi cout 'I'
    loadi cout 'n'
    loadi cout 't'
    loadi cout 'r'
    loadi cout ':'
    loadi cout '0'
    loadi cout '>'
    loadi cout ''
    andi  csr csr intr0_flag_clear
    jump zero zero _iret

intr1:
    loadi cout ''
    loadi cout '<'
    loadi cout 'I'
    loadi cout 'n'
    loadi cout 't'
    loadi cout 'r'
    loadi cout ':'
    loadi cout '1'
    loadi cout '>'
    loadi cout ''
    andi  csr csr intr1_flag_clear
    jump zero zero _iret

intr2:
    loadi cout ''
    loadi cout '<'
    loadi cout 'I'
    loadi cout 'n'
    loadi cout 't'
    loadi cout 'r'
    loadi cout ':'
    loadi cout '2'
    loadi cout '>'
    loadi cout ''
    andi  csr csr intr2_flag_clear
    jump zero zero _iret

intr3:
    loadi cout ''
    loadi cout '<'
    loadi cout 'I'
    loadi cout 'n'
    loadi cout 't'
    loadi cout 'r'
    loadi cout ':'
    loadi cout '3'
    loadi cout '>'
    loadi cout ''
    andi  csr csr intr3_flag_clear
    jump zero zero _iret

init_tasks:
    add  s0 ra zero ; s0 <= ra
    ; setup task A
    loadi a0 task_state_ready
    loadi a1 0x1000 ; stack_size
    loadi a2 task_a ; entry address
    jump ra zero os_task_setup
    store a0 zero task_id_a
    ; setup task B
    loadi a0 task_state_ready
    loadi a1 0x1000 ; stack_size
    loadi a2 task_b ; entry address
    jump ra zero os_task_setup
    store a0 zero task_id_b
    ; setup task C
    loadi a0 task_state_ready
    loadi a1 0x1000 ; stack_size
    loadi a2 task_c ; entry address
    jump ra zero os_task_setup
    store a0 zero task_id_c
    ; os start
    add  ra s0 zero ; ra <= s0 
    jump zero ra 0

task_a:
    loadi cout 'S'
    loadi cout 't'
    loadi cout 'a'
    loadi cout 'r'
    loadi cout 't'
    loadi cout ''
    loadi cout 'A'
    loadi cout '\n'
    loadi s0 0xAAA0
    loadi s1 0xAAA1
    loadi s2 0xAAA2
    loadi s3 0xAAA3
    loadi t0 0xAAB0
    loadi t1 0xAAB1
    loadi t2 0xAAB2
    loadi t3 0xAAB3
    loadi a0 0xAAC0
    loadi a1 0xAAC1
    loadi a2 0xAAC2
    loadi a3 0xAAC3
    jump  ra zero os_task_wait
    loadi cout 'R'
    loadi cout 'e'
    loadi cout 's'
    loadi cout 'u'
    loadi cout 'm'
    loadi cout 'e'
    loadi cout ''
    loadi cout 'A'
    loadi cout '\n'
    ; ready B
    load  a0 zero task_id_b
    jump  ra zero os_task_ready
    jump  ra zero os_task_exit
    
task_b:
    loadi cout 'S'
    loadi cout 't'
    loadi cout 'a'
    loadi cout 'r'
    loadi cout 't'
    loadi cout ''
    loadi cout 'B'
    loadi cout '\n'
    loadi s0 0xBBA0
    loadi s1 0xBBA1
    loadi s2 0xBBA2
    loadi s3 0xBBA3
    loadi t0 0xBBB0
    loadi t1 0xBBB1
    loadi t2 0xBBB2
    loadi t3 0xBBB3
    loadi a0 0xBBC0
    loadi a1 0xBBC1
    loadi a2 0xBBC2
    loadi a3 0xBBC3
    jump  ra zero os_task_wait
    loadi cout 'R'
    loadi cout 'e'
    loadi cout 's'
    loadi cout 'u'
    loadi cout 'm'
    loadi cout 'e'
    loadi cout ''
    loadi cout 'B'
    loadi cout '\n'
    jump  ra zero os_task_exit

task_c:
    loadi cout 'S'   
    loadi cout 't'
    loadi cout 'a'
    loadi cout 'r'
    loadi cout 't'
    loadi cout ''
    loadi cout 'C'
    loadi cout '\n'
    loadi s0 0xCCA0
    loadi s1 0xCCA1
    loadi s2 0xCCA2
    loadi s3 0xCCA3
    loadi t0 0xCCB0
    loadi t1 0xCCB1
    loadi t2 0xCCB2
    loadi t3 0xCCB3
    loadi a0 0xCCC0
    loadi a1 0xCCC1
    loadi a2 0xCCC2
    loadi a3 0xCCC3
    ; ready A
    load  a0 zero task_id_a
    jump  ra zero os_task_ready
    loadi cout 'R'
    loadi cout 'e'
    loadi cout 's'    
    loadi cout 'u'
    loadi cout 'm'
    loadi cout 'e'
    loadi cout ''
    loadi cout 'C'
    loadi cout '\n'
    jump  ra zero os_task_exit
